import flet as ft
from webcam_stream import WebcamStream
from real_time_processor import RealTimeProcessor
from typing import Any
import numpy.typing as npt
from utils import array_to_base64, Filter


def main(page: ft.Page):
    # Default black image
    camera_img_default = "R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs="

    # Declare Image component to show camera capture
    img_camera = ft.Image(
        width=300,
        height=300,
        fit=ft.ImageFit.CONTAIN,
        src_base64=camera_img_default
    )

    # Save Filters enum names to list to be able to iterate over them (for next / prev functionality)
    available_filters = list(
        map(lambda x: x.name, Filter._member_map_.values()))
    # Save current filter index over the filters list to know where you are
    current_filter_index = 0

    page.title = "Flet counter example"
    page.vertical_alignment = ft.MainAxisAlignment.CENTER

    def handle_frame_change(img_camera: ft.Image, frame: npt.NDArray[Any]):
        img_camera.src_base64 = array_to_base64(frame)
        page.update()

    def next_filter(current_filter_index: int, available_filters: list[str], real_time_processor: RealTimeProcessor):
        # Check if the next index doesn't exceed the number of available filters
        if current_filter_index + 1 < len(available_filters):
            current_filter_index += 1
        # real_time_processor.set_current_bg_filter(
        #     Filter[available_filters[current_filter_index]])
        page.update()
        print('Current filter index:', current_filter_index)
        print('Current filter:',
              available_filters[current_filter_index])

    def prev_filter(current_filter_index: int, available_filters: list[str], real_time_processor: RealTimeProcessor):
        # Check if the next index is higher than the number of available filters
        if current_filter_index - 1 >= 0:
            current_filter_index -= 1
        # Update filter to process
        # real_time_processor.set_current_bg_filter(
        #    Filter[available_filters[current_filter_index]])
        page.update()
        print('Current filter index:', current_filter_index)
        print('Current filter:',
              available_filters[current_filter_index])

    def stop_streaming(real_time_processor: RealTimeProcessor, img_camera: ft.Image):
        real_time_processor.stop()
        # Default camera's image to black
        img_camera.src_base64 = camera_img_default
        # Update filter to process
        # real_time_processor.set_current_bg_filter(
        #     Filter[available_filters[current_filter_index]])
        page.update()

    def start_streaming(real_time_processor: RealTimeProcessor):
        real_time_processor.start()
        page.update()

    # initializing and starting multi-threaded webcam capture input stream
    # stream_id = 0 is for primary camera
    webcam_stream = WebcamStream(stream_id=0)
    # webcam_stream.start()

    real_time_processor = RealTimeProcessor(
        on_frame_change=handle_frame_change,
        webcam_stream=webcam_stream)
    # real_time_processor.start()

    page.add(
        ft.Row(
            [
                ft.IconButton(ft.icons.STOP_CIRCLE,
                              on_click=lambda e: stop_streaming(real_time_processor, img_camera)),
                ft.Column(
                    [
                        img_camera,
                        ft.Row([
                            ft.IconButton(ft.icons.SKIP_PREVIOUS,
                                          on_click=lambda e: prev_filter(current_filter_index, available_filters, real_time_processor)),
                            ft.Text(
                                value='Actual background filter:\n' +
                                available_filters[current_filter_index],
                                text_align=ft.TextAlign.CENTER),
                            ft.IconButton(ft.icons.SKIP_NEXT,
                                          on_click=lambda e: next_filter(current_filter_index, available_filters, real_time_processor)),
                        ])
                    ],
                    horizontal_alignment=ft.CrossAxisAlignment.CENTER,
                ),
                ft.IconButton(ft.icons.PLAY_CIRCLE,
                              on_click=lambda e: start_streaming(real_time_processor)),
            ],
            alignment=ft.MainAxisAlignment.CENTER,
        )
    )


ft.app(target=main)
